# JS基本语法

# 注释

多行注释

- 多行注释，注释中的内容不会被执行，但是可以在源代码中查看

- 要养成良好的编写注释的习惯，也可以通过注释来对代码进行一些简单的调试

1.JS中==严格区分大小写==

 2.JS中每一条语句以分号(;)结尾

            \*   - 如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，
    
            \*     而且有些时候，浏览器会加错分号，==所以在开发中分号必须写==

 3.==JS中会忽略多个空格和换行==，所以我们可以利用空格和换行对代码进行格式化

# 字面量和变量

## 字面量

都是一些不可改变的值

            \*   比如 ：1 2 3 4 5 
    
            \*   字面量都是可以直接使用，但是我们一般都不会直接使用字面量

## 变量

==变量可以用来保存字面量==，而且变量的值是可以任意改变的

            \*   ==变量更加方便我们使用==，所以在开发中都是通过变量去保存一个字面量，
    
            \*   而很少直接使用字面量
    
            \*   可以通过变量对字面量进行描述
    
    	\*   字面量有时候很长，如数字位数很多，使用变量很方便的代替字面量

声明变量

- 在js中使用var关键字来声明一个变量

var a=123;      a是变量，123是字面量

![image-20210927184110422](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20210927184110422.png)

# 标识符

在JS中所有的可以由我们自主命名的都可以称为是标识符

   \* - 例如：==变量名、函数名、属性名==都属于标识符

   \* - 命名一个标识符时需要遵守如下的规则：

1.标识符中可以含有字母、数字、_、==$==

2.标识符不能以数字开头

 3.==标识符不能是ES中的关键字或**保留字**==【现在还没用，但是可能会用，成为关键字】    

![image-20210927184825718](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20210927184825718.png)



![image-20210927184842204](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20210927184842204.png)

> ！！！注意一下即可，若使用，程序会自动报错，不用刻意去记住！！！

4.标识符一般都采用驼峰命名法

- 首字母小写，每个单词的开头字母大写，其余字母小写

          \*     helloWorld xxxYyyZzz

- JS底层保存标识符时实际上是采用的Unicode编码【utf-8】，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符

  > utf-8中含有中文，理论上可以用，但是千万不能用；
  >
  > 1,2,3条都是强制要求的，4条不是强制要求的

~~~js
//千万不要这么用
    var 锄禾日当午 = 789;
    console.log(锄禾日当午);
~~~

# 数据类型

指的就是字面量的类型

在JS中一共有六种数据类型：

**基本数据类型**

            \*   String 字符串
    
            \*   Number 数值
    
           \*   Boolean 布尔值
    
            \*   Null 空值
    
            \*   Undefined 未定义

**引用数据类型**

            \*   Object 对象

其中String Number Boolean Null Undefined属于基本数据类型

而Object属于引用数据类型

String字符串

在JS中字符串需要使用引号引起来

- 使用双引号或单引号都可以，但是不要混着用

- 引号不能嵌套，双引号不能放双引号，单引号不能放单引号


在==字符串==中我们可以使用\作为转义字符，当表示一些特殊符号时可以使用\进行转义

           \ \"   表示 "
    
           \\'   表示 '
    
           \n   表示换行
    
            \t   制表符
    
             \\ \  表示\

## Number类型

在JS中所有的数值都是Number类型，包括整数和浮点数（小数）

JS中可以表示的数字的最大值   

==Number.MAX_VALUE==

- 1.7976931348623157e+308

==Number.MIN_VALUE==       大于0的最小值

- 5e-324

如果使用Number表示的数字超过了最大值，则会返回一个

- Infinity 表示正无穷
- -Infinity 表示负无穷

使用typeof检查Infinity也会返回number

==使用typeof检查一个NaN也会返回number==，NaN 是一个特殊的数字，表示Not A Number

可以使用一个运算符 typeof来检查一个变量的类型

             语法：typeof 变量  

- 检查字符串时，会返回string

- 检查数值时，会返回number

在JS中==整数的运算基本可以保证精确==

var c = 1865789 + 7654321;

如果使用JS进行==浮点运算==，可能得到一个不精确的结果，所以==千万不要使用JS进行对精确度要求比较高==的运算  ！！！！

【这种计算可以放到服务器去计算】

var c = 0.1 + 0.2;

![image-20210927192315198](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20210927192315198.png)

> 各种语言，不只是js，都有这个浮点数计算不准确的问题，二进制不能正确的计算1/10，所以浮点数计算都是有问题的；
>
> 一般都可以舍去，但是涉及钱，千万不能舍去

## Boolean 布尔值

布尔值只有两个，主要用来做==逻辑判断==

            \* true表示真
    
            \* false表示假
    
            \* 使用typeof检查一个布尔值时，会返回boolean  

> 千万不能加引号，'true'

## Null类型

Null（空值）类型的==值只有一个，就是null==

null这个值专门用来表示一个为空的==对象==

            \* 使用typeof检查一个null值时，会返回object

## Undefined类型

            \* Undefined（未定义）类型的==值只有一个，就undefind==
    
            \* ==【当声明一个变量，但是并不给变量赋值时】==，它的值就是undefined
    
            \* 使用typeof检查一个undefined时也会返回undefined

~~~js
var a = null;	

var b = undefined;
console.log(typeof b);		
~~~

> true和false，null和undefined，都没有引号



#  强制类型转换

指将一个数据类型强制转换为其他的数据类型

类型转换主要指，将其他的数据类型，转换为

            ==\*   String     Number    Boolean==



## **将其他的数据类型转换为String**

方式一：

            \*   - 调用被转换数据类型的toString()方法

- 该方法不会影响到原变量，它会将转换的结果返回

- 但是注意：**null和undefined这两个值没有toString()方法，** 如果调用他们的方法，会报错

方式二：

            \*   - ==调用String()函数==，并将被转换的数据作为参数传递给函数
    
            \*   - 使用String()函数做强制类型转换时，
    
            \*     **对于Number和Boolean实际上就是调用的toString()方法**，但是对于null和undefined，就不会调用toString()方法
    
            \*       ==它会将 null 直接转换为 "null"==
    
            ==\*       将 undefined 直接转换为 "undefined"==

> true转换成string――'true'；false转换成string――'false'

#

## 将其他的数据类b型转换为Number

**转换方式一：**

使用Number()函数

字符串 --> 数字

?		1.如果是纯数字的字符串，则直接将其转换为数字

?		2.==如果字符串中有非数字的内容，则转换为NaN==

?		3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0

布尔 --> 数字

?		true 转成 1

   	 false 转成 0

null --> 数字   0

undefined --> ==数字 NaN==

**转换方式二：**

这种方式专门用来对付字符串

            \*  parseInt() 把一个字符串转换为一个==整数==
    
            \*  parseFloat() 把一个字符串转换为一个==浮点数==

~~~js
			a = "123567a567px";
			//调用parseInt()函数将a转换为Number
			/*
			 * parseInt()可以将一个字符串中的有效的整数内容去出来，
			 * 	然后转换为Number
			 */
			a = parseInt(a);
			
/*parseFloat()作用和parseInt()类似，不同的是它可以获得有效的小数*/
			a = "123.456.789px";
			a = parseFloat(a);
			
/* 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 */
			a = true;
			a = parseInt(a);  // NaN
			
			a = 198.23;
			a = parseInt(a);
			
			console.log(typeof a);
			console.log(a);
~~~

其他进制的数字

【！！！了解即可！！！】

在js中，如果需要表示16进制的数字，则需要以0x开头

如果需要表示8进制的数字，则需要以0开头

- 如果要要表示2进制的数字，则需要以==0b开头==，但是不是所有的浏览器都支持

~~~js
 //十六进制
    a = 0x10;
    a = 0xff;
    a = 0xCafe;
    //八进制数字
     a = 070;

     //二进制数字
     //a = 0b10;
    //向"070"这种字符串，有些浏览器会当成8进制解析，有些会当成10进制解析
    a = "070";
     //可以在parseInt()中传递一个第二个参数，来指定数字的进制
    a = parseInt(a,10);
~~~

##  **将其他的数据类型转换为Boolean**

使用Boolean()函数

数字 ---> 布尔

            \*     - 除了0和==NaN==，其余的都是true

字符串 ---> 布尔

            \*     - 除了空串，其余的都是true

==null和undefined都会转换为false==

==对象也会转换为true==

# 算数运算符

==运算符也叫操作符==

* 通过运算符可以对一个或多个值进行运算,并获取运算结果

比如：==**typeof**就是运算符==，可以来获得一个值的类型，它会将该值的类型以==字符串==的形式返回

* number    string    boolean    undefined     object



算数运算符

当对非Number类型的值进行运算时，会将这些值转换为Number然后在运算

【除去字符串的加法！！！】

==任何值和NaN做运算都得NaN==

 **+**

* +可以对两个值进行加法运算，并将结果返回

* 如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回

* ==任何的值和字符串做加法运算==，都会先转换为字符串，然后再和字符串做拼串的操作

* 我们可以利用这一特点，来将一个任意的数据类型转换为String

* 我们只需要为任意的数据类型 + 一个 "" 即可将其转换为String，这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用==String()函数==

**-**

- 可以对两个值进行减法运算，并将结果返回

*

* 可以对两个值进行乘法运算

~~~js
result = 2 * undefined;  // NaN，任何值和NaN运算都是NaN
result = 2 * null;  // 0
~~~

 **/**

* / 可以对两个值进行除法运算

**%**

            \*     % 取模运算（取余数）



任何值做-   *   /运算时都会自动转换为==Number==

**我们可以利用这一特点做==隐式的类型转换==，可以通过为一个值 -0    *1     /1来将其转换为Number，原理和Number()函数一样，使用起来更加简单**

> 任何值和字符串相加都会转换为字符串，并做拼串操作；

  \* 我们可以利用这一特点，来将一个任意的数据类型转换为String

          \* 我们只需要为任意的数据类型 + 一个 "" 即可将其转换为String
    
           \* 这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数

> ！！！一般运算符不会改变原变量的值，将结果作为返回值进行返回



##  一元运算符

只需要一个操作数

* +正号

正号不会对数字产生任何影响

* -负号

负号可以对数字进行负号的取反

【隐式类型转换】

对于非Number类型的值，它会将先转换为Number，然后在运算

可以对一个其他的数据类型使用+，来将其转换为number，它的原理和Number()函数一样==

![image-20211004121951850](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20211004121951850.png)

![image-20211004122124096](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20211004122124096.png)

## 自增和自减

### 自增 ++

            \*  - 通过自增可以使变量在自身的基础上增加1
    
            \*  - **对于一个变量自增以后，原变量的值会立即自增1**  

【少数几个直接影响原变量的值的方法，特别注意，原变量在自增之后，已经完全发生变化】

            \*  - 自增分成两种：后++(a++) 和 前++(++a)  
    
            \*   无论是a++ 还是 ++a，都会立即使原变量的值自增1
    
            \*     不同的是a++ 和 ++a的值不同
    
            \*   a++的值等于原变量的值（自增前的值）
    
            \*   ++a的值等于新值 （自增后的值）

![image-20211004122947997](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20211004122947997.png)

### 自减 --

            \* - 通过自减可以使变量在自身的基础上减1
    
            \* - 自减分成两种：后--(a--) 和 前--(--a)
    
            \*   无论是a-- 还是 --a 都会**立即使原变量的值自减1**
    
            \*     不同的是a-- 和 --a的值不同
    
            \*       a-- 是变量的原值 （自减前的值）
    
            \*       --a 是变量的新值 （自减以后的值）

> 基本的优先级需要记住：
>
> 指针最优，单目运算优于双目运算。如正负号，自增自减。
>
> 先算术运算，后移位运算，最后位运算。请特别注意：逻辑运算最后结合。
>
> 赋值在最后

# 逻辑运算符

 JS中为我们提供了三种逻辑运算符

包括两类数据：布尔值和非布尔值，其他语言中，不能对非布尔值进行处理，js非常强大

**!    非**

?                \* - !可以用来对一个值进行非运算

?                \* - 所谓非运算就是值对一个==**布尔值**==进行取反操作，

?                \*   true变false，false变true

?                \* - 如果对一个值进行两次取反，它不会变化

?                \* - 如果对**==非布尔值==**进行运算，则会将其转换为布尔值，然后再取反

?                \*   所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值

?                \*   可以为一个任意数据类型取两次反，来将其转换为布尔值，

?                \*   原理和Boolean()函数一样

**&&   与**

?                \* - &&可以对符号两侧的值进行与运算并返回结果

?                \* - 运算规则

?                \*   - 两个值中只要有一个值为false就返回false，只有两个值都为true时，才会返回true

JS中的“与”属于短路的与，如果第一个值为false，则不会看第二个值

**||   或**

?                \* - ||可以对符号两侧的值进行或运算并返回结果

?                \* - 运算规则：

?                \*   - 两个值中只要有一个true，就返回true

?                \*     如果两个值都为false，才返回false

JS中的“或”属于短路的或，如果第一个值为true，则不会检查第二个值

&&   ||    **非布尔值**的情况

?               \* - ==对于非布尔值进行**与或**运算时，会先将其转换为布尔值，然后再运算，并且返回原值==

与运算

?               \*   - 如果第一个值为true，**则必然返回第二个值**

?               \*   - 如果第一个值为false，则直接返回第一个值

或运算

?               \*   - 如果第一个值为true，则直接返回第一个值

?               \*   - 如果第一个值为false，**则返回第二个值**

~~~js
			//true && true  true && false
			//与运算：如果两个值都为true，则返回后边的
			var result = 5 && 6;
			
			
			//与运算：如果两个值中有false，则返回靠前的false
			//false && true
			result = 0 && 2;
			result = 2 && 0;
			//false &&　false
			result = NaN && 0;
			result = 0 && NaN;
			
			
			//true || true
			//如果第一个值为true，则直接返回第一个值
			result = 2 || 1;
			result = 2 || NaN;
			result = 2 || 0;
			
			//如果第一个值为false，则直接返回第二个值
			result = NaN || 1;
			result = NaN || 0;
			
			result = "" || "hello";
			
			result = -1 || "你好";  // -1

~~~

# 赋值运算符

 =

?               \* 可以将符号右侧的值赋值给符号左侧的变量

+= 

?               \* a += 5 等价于 a = a + 5

-=

?               \* a -= 5 等价于 a = a - 5

*=

?               \* a *= 5 等价于 a = a * 5

/=

?               \* a /= 5 等价于 a = a / 5

%=

?               \* a %= 5 等价于 a = a % 5

# 关系运算符

通过关系运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false

?               \* >大于号

?               \* - 判断符号左侧的值是否大于右侧的值

?               \* - 如果关系成立，返回true，如果关系不成立则返回false

?               \* >= 大于等于   

?               \* - 判断符号左侧的值是否大于或等于右侧的值

?               \* < 小于号

?               \* <= 小于等于



非数值的情况

?               \* - 对于非数值进行比较时，会将其转换为==数字==然后在比较

?               \* - ==如果符号两侧的值都是字符串时==，不会将其转换为数字进行比较，而会分别比较字符串中字符的Unicode编码

~~~js
			//console.log(1 > true);   //false
			//console.log(1 >= true);   //true
			//console.log(1 > "0");   //true
			//console.log(10 > null);   //true
			//任何值和NaN做任何比较都是false
			//console.log(10 <= "hello");  //    NaN  false
			//console.log(true > false);   //true   1>0			
			//console.log("1" < "5");   //true
			//console.log("11" < "5");   //true

			//比较两个字符串时，比较的是字符串的字符编码
			//console.log("a" < "b");   //true
			//比较字符编码时是一位一位进行比较
			//如果两位一样，则比较下一位，所以借用它来对英文进行排序
			//console.log("abc" < "bcd");  //true
			//比较中文时没有意义，直接忽略，通常不适用
			//console.log("戒" > "我");   //true
			
//如果比较的两个字符串型的数字，可能会得到不可预期的结果
//注意：在比较两个字符串型的数字时，一定一定一定要转型！！！
console.log("11123123123123123123" < +"5");   //false
~~~

> 在比较两个字符串型的数字时，一定一定一定要转型！！！

# 编码

搜集Unicode编码表？？？ 

在字符串中使用转义字符输入Unicode编码

?               \* \u四位编码  【十六进制】

  		console.log("\u2620");

在网页中使用Unicode编码

?              &#编码;       这里的编码需要的是10进制

![image-20211004133910928](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20211004133910928.png)

# 相等运算符

相等运算符用来比较两个值是否相等，如果相等会返回true，否则返回false

?               \* 使用 == 来做相等运算

?               \* - 当使用来比较两个值时，如果值的类型不同，则会==自动进行类型转换==【大部分会将其转换成数字，但是不是全部确定】，将其转换为相同的类型，然后再比较

?               \* !=    不相等

?               \*  不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false

?               \* - 使用 != 来做不相等运算

?               \* - 不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false

?               \* ===    全等

?               \*   - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换

?               \*     如果两个值的类型不同，直接返回false

?               \* !==  不全等

?               \*   - 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换

?               \*     如果两个值的类型不同，直接返回true

~~~js
console.log(true == "1");   //true，都转为数字		
console.log(null == 0);   //false，没有转成数字

			 // undefined 衍生自 null
			 // 所以这两个值做相等判断时，会返回true
			
			//console.log(undefined == null);
			
			// NaN不和任何值相等，包括他本身
			//console.log(NaN == NaN);  //false
		
			var b = NaN;
			//判断b的值是否是NaN
			//console.log(b == NaN);  

/*可以通过isNaN()函数来判断一个值是否是NaN，如果该值是NaN则返回true，否则返回false*/
			//console.log(isNaN(b));
			
			//console.log(10 != 5); //true
			//console.log(10 != 10); //false
			//console.log("abcd" != "abcd"); //false
			//console.log("1" != 1);//false
			
			//console.log("123" === 123);    //false
			//console.log(null === undefined);  //false
			
			console.log(1 !== "1");    //true
~~~

# 条件运算符

条件运算符也叫三元运算符

语法：

?               \*   条件表达式  语句1:语句2;

执行的流程：

?               \*   条件运算符在执行时，首先对==条件表达式==进行求值，

?               \*     如果该值为true，则执行语句1，并返回执行结果

?               \*     如果该值为false，则执行语句2，并返回执行结果

?               \*   如果条件的表达式的求值结果是一个==非布尔值==，会将其转换为布尔值然后在运算

~~~js
//false  alert("语句1"):alert("语句2");		
			var a = 300;
			var b = 143;
			var c = 50;
			
			//a > b    alert("a大"):alert("b大");
			
			//获取a和b中的最大值
			//var max = a > b    a : b;
			//获取a b c 中的大值
			//max = max > c    max : c;
			
			//这种写法不推荐使用，不方便阅读，性能不高
			var max = a > b    (a > c    a :c) : (b > c    b : c);
			
			//console.log("max = "+max);
			
			//"hello"  alert("语句1"):alert("语句2");
~~~

# 运算符的优先级

, 运算符

?               \* 使用,可以分割多个语句，一般可以在声明多个变量时使用,

?              //使用,运算符同时声明多个变量

?              //var a , b , c;

?              //可以同时声明多个变量并赋值

?              //var a=1 , b=2 , c=3;

?              //alert(b);

但是这个表我们并不需要记忆，如果遇到优先级不清楚，==可以使用()来改变优先级==【拿不准的时候可以使用括号】

var result = 1 || 2 && 3;      // 1



在JS中有一个运算符优先级的表，在表中越靠上优先级越高，优先级越高越优先计算，如果优先级一样，则从左往右计算。

【将这个表背下来】

![image-20211004141426953](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20211004141426953.png)

# 逻辑运算符

 JS中为我们提供了三种逻辑运算符

包括两类数据：布尔值和非布尔值，其他语言中，不能对非布尔值进行处理，js非常强大

**!    非**

?                \* - !可以用来对一个值进行非运算

?                \* - 所谓非运算就是值对一个==**布尔值**==进行取反操作，

?                \*   true变false，false变true

?                \* - 如果对一个值进行两次取反，它不会变化

?                \* - 如果对**==非布尔值==**进行运算，则会将其转换为布尔值，然后再取反

?                \*   所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值

?                \*   可以为一个任意数据类型取两次反，来将其转换为布尔值，

?                \*   原理和Boolean()函数一样

**&&   与**

?                \* - &&可以对符号两侧的值进行与运算并返回结果

?                \* - 运算规则

?                \*   - 两个值中只要有一个值为false就返回false，只有两个值都为true时，才会返回true

JS中的“与”属于短路的与，如果第一个值为false，则不会看第二个值

**||   或**

?                \* - ||可以对符号两侧的值进行或运算并返回结果

?                \* - 运算规则：

?                \*   - 两个值中只要有一个true，就返回true

?                \*     如果两个值都为false，才返回false

JS中的“或”属于短路的或，如果第一个值为true，则不会检查第二个值

&&   ||    **非布尔值**的情况

?               \* - ==对于非布尔值进行**与或**运算时，会先将其转换为布尔值，然后再运算，并且返回原值==

与运算

?               \*   - 如果第一个值为true，**则必然返回第二个值**

?               \*   - 如果第一个值为false，则直接返回第一个值

或运算

?               \*   - 如果第一个值为true，则直接返回第一个值

?               \*   - 如果第一个值为false，**则返回第二个值**

~~~js
			//true && true  true && false
			//与运算：如果两个值都为true，则返回后边的
			var result = 5 && 6;
			
			
			//与运算：如果两个值中有false，则返回靠前的false
			//false && true
			result = 0 && 2;
			result = 2 && 0;
			//false &&　false
			result = NaN && 0;
			result = 0 && NaN;
			
			
			//true || true
			//如果第一个值为true，则直接返回第一个值
			result = 2 || 1;
			result = 2 || NaN;
			result = 2 || 0;
			
			//如果第一个值为false，则直接返回第二个值
			result = NaN || 1;
			result = NaN || 0;
			
			result = "" || "hello";
			
			result = -1 || "你好";  // -1

~~~

# 赋值运算符

 =

?               \* 可以将符号右侧的值赋值给符号左侧的变量

+= 

?               \* a += 5 等价于 a = a + 5

-=

?               \* a -= 5 等价于 a = a - 5

*=

?               \* a *= 5 等价于 a = a * 5

/=

?               \* a /= 5 等价于 a = a / 5

%=

?               \* a %= 5 等价于 a = a % 5

# 关系运算符

通过关系运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false

?               \* >大于号

?               \* - 判断符号左侧的值是否大于右侧的值

?               \* - 如果关系成立，返回true，如果关系不成立则返回false

?               \* >= 大于等于   

?               \* - 判断符号左侧的值是否大于或等于右侧的值

?               \* < 小于号

?               \* <= 小于等于



非数值的情况

?               \* - 对于非数值进行比较时，会将其转换为==数字==然后在比较

?               \* - ==如果符号两侧的值都是字符串时==，不会将其转换为数字进行比较，而会分别比较字符串中字符的Unicode编码

~~~js
			//console.log(1 > true);   //false
			//console.log(1 >= true);   //true
			//console.log(1 > "0");   //true
			//console.log(10 > null);   //true
			//任何值和NaN做任何比较都是false
			//console.log(10 <= "hello");  //    NaN  false
			//console.log(true > false);   //true   1>0			
			//console.log("1" < "5");   //true
			//console.log("11" < "5");   //true

			//比较两个字符串时，比较的是字符串的字符编码
			//console.log("a" < "b");   //true
			//比较字符编码时是一位一位进行比较
			//如果两位一样，则比较下一位，所以借用它来对英文进行排序
			//console.log("abc" < "bcd");  //true
			//比较中文时没有意义，直接忽略，通常不适用
			//console.log("戒" > "我");   //true
			
//如果比较的两个字符串型的数字，可能会得到不可预期的结果
//注意：在比较两个字符串型的数字时，一定一定一定要转型！！！
console.log("11123123123123123123" < +"5");   //false
~~~

> 在比较两个字符串型的数字时，一定一定一定要转型！！！

# 编码

搜集Unicode编码表？？？ 

在字符串中使用转义字符输入Unicode编码

?               \* \u四位编码  【十六进制】

  		console.log("\u2620");

在网页中使用Unicode编码

?              &#编码;       这里的编码需要的是10进制

![image-20211004133910928](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20211004133910928.png)

# 相等运算符

相等运算符用来比较两个值是否相等，如果相等会返回true，否则返回false

?               \* 使用 == 来做相等运算

?               \* - 当使用来比较两个值时，如果值的类型不同，则会==自动进行类型转换==【大部分会将其转换成数字，但是不是全部确定】，将其转换为相同的类型，然后再比较

?               \* !=    不相等

?               \*  不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false

?               \* - 使用 != 来做不相等运算

?               \* - 不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false

?               \* ===    全等

?               \*   - 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换

?               \*     如果两个值的类型不同，直接返回false

?               \* !==  不全等

?               \*   - 用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换

?               \*     如果两个值的类型不同，直接返回true

~~~js
console.log(true == "1");   //true，都转为数字		
console.log(null == 0);   //false，没有转成数字

			 // undefined 衍生自 null
			 // 所以这两个值做相等判断时，会返回true
			
			//console.log(undefined == null);
			
			// NaN不和任何值相等，包括他本身
			//console.log(NaN == NaN);  //false
		
			var b = NaN;
			//判断b的值是否是NaN
			//console.log(b == NaN);  

/*可以通过isNaN()函数来判断一个值是否是NaN，如果该值是NaN则返回true，否则返回false*/
			//console.log(isNaN(b));
			
			//console.log(10 != 5); //true
			//console.log(10 != 10); //false
			//console.log("abcd" != "abcd"); //false
			//console.log("1" != 1);//false
			
			//console.log("123" === 123);    //false
			//console.log(null === undefined);  //false
			
			console.log(1 !== "1");    //true
~~~

# 条件运算符

条件运算符也叫三元运算符

语法：

?               \*   条件表达式  语句1:语句2;

执行的流程：

?               \*   条件运算符在执行时，首先对==条件表达式==进行求值，

?               \*     如果该值为true，则执行语句1，并返回执行结果

?               \*     如果该值为false，则执行语句2，并返回执行结果

?               \*   如果条件的表达式的求值结果是一个==非布尔值==，会将其转换为布尔值然后在运算

~~~js
//false  alert("语句1"):alert("语句2");		
			var a = 300;
			var b = 143;
			var c = 50;
			
			//a > b    alert("a大"):alert("b大");
			
			//获取a和b中的最大值
			//var max = a > b    a : b;
			//获取a b c 中的大值
			//max = max > c    max : c;
			
			//这种写法不推荐使用，不方便阅读，性能不高
			var max = a > b    (a > c    a :c) : (b > c    b : c);
			
			//console.log("max = "+max);
			
			//"hello"  alert("语句1"):alert("语句2");
~~~

# 运算符的优先级

, 运算符

?               \* 使用,可以分割多个语句，一般可以在声明多个变量时使用,

?              //使用,运算符同时声明多个变量

?              //var a , b , c;

?              //可以同时声明多个变量并赋值

?              //var a=1 , b=2 , c=3;

?              //alert(b);

但是这个表我们并不需要记忆，如果遇到优先级不清楚，==可以使用()来改变优先级==【拿不准的时候可以使用括号】

var result = 1 || 2 && 3;      // 1



在JS中有一个运算符优先级的表，在表中越靠上优先级越高，优先级越高越优先计算，如果优先级一样，则从左往右计算。

【将这个表背下来】

![image-20211004141426953](C:\Users\Carrie_Lee\AppData\Roaming\Typora\typora-user-images\image-20211004141426953.png)

